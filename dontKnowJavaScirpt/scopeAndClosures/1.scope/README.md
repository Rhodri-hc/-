小黄书一开始就讲解了编译原理的内容:

此部分内容跟 Vuejs 的设计实现中的编译部分有所差异：

>Vuejs主要分为：parse（生成模板AST）--> transfer(模板AST 转换为 js AST) --> generate(生成render 执行函数)

>javaScript 分为三个步骤：分词/词法分析 --> 解析/语法分析 --> 代码生成

简单来说，任何 javaScript 代码片段在执行前都要进行编译（通常是执行前）。因此，因此 javaScript 编译器首先会对 `var a = 2;`  这段程序进行编译，然后做好执行它的准备，并且通常马上会执行它。

-------------------------
为了理解作用域，引入引擎，编译器，作用域的三个概念：

>引擎：从头到尾负责整个 javaScript 程序的编译及执行过程。

>编译器：负责语法分析及代码生成等脏活累活。

>作用域：负责收集并维护由所有标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

就拿简单的变量赋值 `var a = 2;` 来说，变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有生命过），然后在运行时引擎会在作用域中查找改变量，如果能够找到就会对它赋值。

---------------------------
接着讲查找变量的类型，引入了两个概念： LHS查询 和 RHS查询

简单来说，RHS查询相当于查找某个变量的值，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。
例如：

````javaScript
function foo(a) {  
    var b = a;  
    return a + b;
} 
var c = foo( 2 );
````
这个代码片段就有 3 处LHS查询，4 处RHS查询。

------------------------------
接着讲解了作用域嵌套：

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。

因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

-----------------------------

最后讲解了 进行查询时发生的异常 ：

如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。值得注意的是，ReferenceError是非常重要的异常类型。

如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError

当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。


